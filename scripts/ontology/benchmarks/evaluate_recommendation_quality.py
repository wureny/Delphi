#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Evaluate recommendation-quality metrics from runtime output payload."
    )
    parser.add_argument(
        "--input",
        required=True,
        help="Path to runtime output JSON generated by run_multi_agent_runtime.py.",
    )
    parser.add_argument("--output", help="Optional path to write metrics JSON.")
    parser.add_argument("--pretty", action="store_true", help="Pretty-print JSON output.")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    payload = json.loads(Path(args.input).read_text(encoding="utf-8"))
    metrics = evaluate_recommendation_quality(payload)
    text = json.dumps(metrics, indent=2 if args.pretty else None)
    if args.output:
        Path(args.output).write_text(text + "\n", encoding="utf-8")
        print(f"[recommendation-quality] wrote {args.output}")
    else:
        print(text)
    return 0


def evaluate_recommendation_quality(runtime_payload: dict[str, Any]) -> dict[str, Any]:
    runtime_context = runtime_payload.get("runtime_agent_context") or {}
    candidate_decisions = runtime_context.get("candidate_decisions") or []
    strategy_results = runtime_context.get("strategy_agent_results") or []
    risk_results = runtime_context.get("risk_agent_results") or []
    gate_results = (runtime_payload.get("risk_gate_payload") or {}).get("gate_results") or []
    orders = (runtime_payload.get("order_proposals_payload") or {}).get("orders") or []
    paper_payload = runtime_payload.get("paper_trading_payload") or {}

    total_decisions = len(candidate_decisions)
    actionable_decisions = [item for item in candidate_decisions if normalize_action(item.get("proposed_action")) != "hold"]
    hold_decisions = [item for item in candidate_decisions if normalize_action(item.get("proposed_action")) == "hold"]
    actionable_count = len(actionable_decisions)
    hold_count = len(hold_decisions)
    actionable_rate = safe_ratio(actionable_count, total_decisions)

    risk_block_count = 0
    risk_block_action_leak_count = 0
    for row in candidate_decisions:
        if str(row.get("risk_gate")) != "block":
            continue
        risk_block_count += 1
        if normalize_action(row.get("proposed_action")) != "hold":
            risk_block_action_leak_count += 1
    risk_block_leak_rate = safe_ratio(risk_block_action_leak_count, risk_block_count)
    risk_block_alignment_rate = 1.0 - risk_block_leak_rate if risk_block_count > 0 else 1.0

    strategy_by_key = {
        (str(item.get("market_id")), str(item.get("outcome_id"))): item
        for item in strategy_results
        if isinstance(item, dict)
    }
    strategy_alignment_hits = 0
    strategy_alignment_total = 0
    for decision in candidate_decisions:
        key = (str(decision.get("market_id")), str(decision.get("outcome_id")))
        strategy = strategy_by_key.get(key)
        if strategy is None:
            continue
        strategy_alignment_total += 1
        expected_action = recommendation_to_action(strategy.get("strategy_recommendation"))
        if normalize_action(decision.get("proposed_action")) == expected_action:
            strategy_alignment_hits += 1
    strategy_action_alignment_rate = safe_ratio(strategy_alignment_hits, strategy_alignment_total)

    allow_gate_count = 0
    review_gate_count = 0
    block_gate_count = 0
    for row in gate_results:
        gate = str(row.get("gate"))
        if gate == "allow":
            allow_gate_count += 1
        elif gate == "review":
            review_gate_count += 1
        elif gate == "block":
            block_gate_count += 1
    gate_total = len(gate_results)
    gate_allow_rate = safe_ratio(allow_gate_count, gate_total)
    gate_review_rate = safe_ratio(review_gate_count, gate_total)
    gate_block_rate = safe_ratio(block_gate_count, gate_total)

    approved_orders = sum(1 for row in orders if str(row.get("status")) == "approved")
    proposed_orders = sum(1 for row in orders if str(row.get("status")) == "proposed")
    rejected_orders = sum(1 for row in orders if str(row.get("status")) == "rejected")
    submitted_orders = approved_orders + proposed_orders
    order_rejection_rate = safe_ratio(rejected_orders, len(orders))

    actionable_confidence = average_confidence(actionable_decisions)
    hold_confidence = average_confidence(hold_decisions)
    high_confidence_actionable = sum(1 for row in actionable_decisions if safe_float(row.get("confidence")) >= 0.55)
    high_confidence_actionable_rate = safe_ratio(high_confidence_actionable, actionable_count)

    runtime_engine = runtime_payload.get("runtime_engine")
    session_id = runtime_payload.get("session_id")

    paper_metrics = extract_paper_quality_metrics(paper_payload)
    risk_reason_coverage = count_unique_risk_reasons(risk_results)

    return {
        "schema_version": "v0.1",
        "generated_at": runtime_payload.get("generated_at"),
        "runtime_engine": runtime_engine,
        "session_id": session_id,
        "metrics": {
            "total_candidate_decisions": total_decisions,
            "actionable_candidate_decisions": actionable_count,
            "hold_candidate_decisions": hold_count,
            "candidate_actionable_rate": actionable_rate,
            "risk_block_decisions": risk_block_count,
            "risk_block_action_leak_count": risk_block_action_leak_count,
            "risk_block_alignment_rate": round(risk_block_alignment_rate, 6),
            "strategy_action_alignment_rate": strategy_action_alignment_rate,
            "average_actionable_confidence": actionable_confidence,
            "average_hold_confidence": hold_confidence,
            "high_confidence_actionable_rate": high_confidence_actionable_rate,
            "gate_allow_rate": gate_allow_rate,
            "gate_review_rate": gate_review_rate,
            "gate_block_rate": gate_block_rate,
            "approved_orders": approved_orders,
            "proposed_orders": proposed_orders,
            "submitted_orders": submitted_orders,
            "rejected_orders": rejected_orders,
            "order_rejection_rate": order_rejection_rate,
            "unique_risk_reason_count": risk_reason_coverage,
            **paper_metrics,
        },
        "notes": [
            "strategy_action_alignment_rate checks candidate action against mapped strategy recommendation.",
            "risk_block_alignment_rate expects risk_gate=block decisions to resolve to hold.",
            "paper metrics are zeroed when paper_trading_payload is absent.",
        ],
    }


def extract_paper_quality_metrics(paper_payload: dict[str, Any]) -> dict[str, Any]:
    if not isinstance(paper_payload, dict) or not paper_payload:
        return {
            "paper_executed_orders": 0,
            "paper_skipped_orders": 0,
            "paper_execution_fill_rate": 0.0,
            "paper_net_realized_pnl_usd": 0.0,
            "paper_realized_pnl_positive": 0.0,
        }
    executed = int(paper_payload.get("executed_order_count", 0))
    skipped = int(paper_payload.get("skipped_order_count", 0))
    total = executed + skipped
    pnl_summary = paper_payload.get("pnl_summary") or {}
    net_realized = safe_float(pnl_summary.get("net_realized_pnl_usd"))
    return {
        "paper_executed_orders": executed,
        "paper_skipped_orders": skipped,
        "paper_execution_fill_rate": safe_ratio(executed, total),
        "paper_net_realized_pnl_usd": net_realized,
        "paper_realized_pnl_positive": 1.0 if net_realized > 0 else 0.0,
    }


def count_unique_risk_reasons(risk_results: list[dict[str, Any]]) -> int:
    reasons: set[str] = set()
    for row in risk_results:
        if not isinstance(row, dict):
            continue
        for reason in row.get("risk_reasons", []):
            text = str(reason).strip()
            if text:
                reasons.add(text)
    return len(reasons)


def average_confidence(rows: list[dict[str, Any]]) -> float:
    if not rows:
        return 0.0
    values = [safe_float(row.get("confidence")) for row in rows]
    return round(sum(values) / len(values), 6)


def safe_ratio(numerator: int, denominator: int) -> float:
    if denominator <= 0:
        return 0.0
    return round(float(numerator) / float(denominator), 6)


def safe_float(value: Any) -> float:
    try:
        parsed = float(value)
    except (TypeError, ValueError):
        return 0.0
    return round(parsed, 6)


def normalize_action(value: Any) -> str:
    action = str(value or "hold").strip().lower()
    if action in {"buy", "sell", "hold", "reduce", "exit"}:
        return action
    return "hold"


def recommendation_to_action(value: Any) -> str:
    recommendation = str(value or "hold").strip().lower()
    if recommendation == "consider_buy":
        return "buy"
    if recommendation == "consider_sell":
        return "sell"
    return "hold"


if __name__ == "__main__":
    raise SystemExit(main())
