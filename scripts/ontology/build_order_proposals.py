#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any

DEFAULT_PORTFOLIO_ID = "pf_main"


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Build minimal order proposals from decision records and risk gate results.")
    parser.add_argument("--decision-records", required=True, help="Path to decision-records JSON generated by build_decision_records.py.")
    parser.add_argument("--risk-gate-report", required=True, help="Path to risk gate report JSON generated by evaluate_risk_policy_gate.py.")
    parser.add_argument("--execution-bundle", required=True, help="Path to the current fund execution bundle JSON.")
    parser.add_argument("--portfolio-id", default=DEFAULT_PORTFOLIO_ID, help="Portfolio account id to assign to proposed orders.")
    parser.add_argument("--order-type", choices=["market", "limit"], default="limit", help="Order type for emitted proposals.")
    parser.add_argument("--output", required=True, help="Path to write order proposals JSON.")
    parser.add_argument("--pretty", action="store_true", help="Pretty-print JSON output.")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    decision_payload = json.loads(Path(args.decision_records).read_text(encoding="utf-8"))
    gate_payload = json.loads(Path(args.risk_gate_report).read_text(encoding="utf-8"))
    execution_bundle = json.loads(Path(args.execution_bundle).read_text(encoding="utf-8"))
    proposals = build_order_proposals(
        decision_payload=decision_payload,
        gate_payload=gate_payload,
        execution_bundle=execution_bundle,
        portfolio_id=args.portfolio_id,
        order_type=args.order_type,
    )
    indent = 2 if args.pretty else None
    Path(args.output).write_text(json.dumps(proposals, indent=indent) + "\n", encoding="utf-8")
    print(f"[order-proposals] wrote {args.output} count={len(proposals['orders'])}")
    return 0


def build_order_proposals(
    decision_payload: dict[str, Any],
    gate_payload: dict[str, Any],
    execution_bundle: dict[str, Any],
    portfolio_id: str,
    order_type: str,
) -> dict[str, Any]:
    gate_by_decision = {item["decision_id"]: item for item in gate_payload.get("gate_results", [])}
    strategies = existing_order_ids(execution_bundle)
    orders = []
    skipped = []
    for record in decision_payload.get("decision_records", []):
        gate = gate_by_decision.get(record["id"])
        if gate is None:
            skipped.append({"decision_record_id": record["id"], "reason": "missing_gate_result"})
            continue
        if normalize_action(record["proposed_action"]) == "hold":
            skipped.append({"decision_record_id": record["id"], "reason": "hold_is_not_orderable"})
            continue
        side = map_action_to_side(record["proposed_action"])
        quantity = float(gate.get("proposed_quantity", 0.0))
        limit_price = float(gate.get("price_proxy", 0.0)) if order_type == "limit" else None
        order_id = unique_order_id(record["id"], strategies)
        orders.append(
            {
                "id": order_id,
                "portfolio_id": portfolio_id,
                "market_id": record["market_id"],
                "outcome_id": record["outcome_id"],
                "side": side,
                "order_type": order_type,
                "quantity": round(quantity, 6),
                "limit_price": round(limit_price, 6) if limit_price is not None else None,
                "status": gate_to_order_status(gate["gate"]),
                "decision_record_id": record["id"],
                "gate": gate["gate"],
                "requires_human_approval": bool(gate.get("requires_human_approval", False)),
                "reasons": gate.get("reasons", []),
            }
        )
    return {
        "schema_version": "v0.1",
        "generated_at": decision_payload.get("generated_at") or gate_payload.get("generated_at"),
        "portfolio_id": portfolio_id,
        "orders": orders,
        "skipped_decisions": skipped,
    }


def existing_order_ids(execution_bundle: dict[str, Any]) -> set[str]:
    return {str(item.get("id")) for item in execution_bundle.get("orders", []) if item.get("id") is not None}


def unique_order_id(decision_id: str, existing: set[str]) -> str:
    base = f"ord_{decision_id}"
    if base not in existing:
        existing.add(base)
        return base
    suffix = 2
    while f"{base}_{suffix}" in existing:
        suffix += 1
    order_id = f"{base}_{suffix}"
    existing.add(order_id)
    return order_id


def map_action_to_side(action: str) -> str:
    normalized = str(action).strip().lower()
    if normalized in {"sell", "reduce", "exit"}:
        return "sell"
    return "buy"


def normalize_action(value: Any) -> str:
    action = str(value or "hold").strip().lower()
    if action in {"buy", "sell", "hold", "reduce", "exit"}:
        return action
    return "hold"


def gate_to_order_status(gate: str) -> str:
    if gate == "allow":
        return "approved"
    if gate == "review":
        return "proposed"
    return "rejected"


if __name__ == "__main__":
    raise SystemExit(main())
